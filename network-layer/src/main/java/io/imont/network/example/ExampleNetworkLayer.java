package io.imont.network.example;

import io.imont.lion.drivers.DriverMetadata;
import io.imont.lion.network.*;
import io.imont.network.example.hardwareaccess.ExampleHardwareAccess;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import rx.Observable;
import rx.Single;
import rx.subjects.PublishSubject;
import rx.subjects.SerializedSubject;
import rx.subjects.Subject;

public class ExampleNetworkLayer extends AbstractNetworkLayer {

    private static final Logger log = LoggerFactory.getLogger(ExampleNetworkLayer.class);

    private static final String NETWORK_IDENTIFIER = "example";

    private Subject<DeviceCandidate, DeviceCandidate> candidateSubject;

    private Subject<NetworkEvent, NetworkEvent> eventSubject;

    /**
     * Connection to our network.
     * Ordinarily, this would be a connection to a serial port or across a socket or something.
     * For this example, we will just talk to an object which is our example hardware access network.
     */
    private ExampleHardwareAccess exampleHardwareAccess = new ExampleHardwareAccess();

    private ExampleDriverInterface drvInf = new ExampleDriverInterface(exampleHardwareAccess);

    public ExampleNetworkLayer() {
        candidateSubject = new SerializedSubject<>(PublishSubject.create());
        eventSubject = new SerializedSubject<>(PublishSubject.create());
    }

    @Override
    public String getVersion() {
        // Return the current version of the network layer.  Normally this value would be generated by
        // build scripts and the CI environment.
        return "0.1-SNAPSHOT";
    }

    @Override
    public String getIdentifier() {
        // Return an identifier for this Network Layer which must be unique within the instance of Lion.
        // Other network layers could return strings such as "ZigBee", "BLE" etc. Drivers will use this
        // identifier to reference the network layer they intend to interact with.
        return NETWORK_IDENTIFIER;
    }

    @Override
    public Object getPublicInterface() {
        // Return an interface to this layer. This will be something that's available within JavaScript
        // drivers that use this layer.
        return drvInf;
    }

    @Override
    public Observable<NetworkEvent> events() {
        // Stream of events coming from this network layer.  Many network protocols are asynchronous so as
        // well as responses to driver requests, unsolicited messages would also be emitted from this observable.
        return eventSubject.asObservable();
    }

    @Override
    public Observable<DeviceCandidate> discover() {
        return newDevices().doOnSubscribe(() -> exampleHardwareAccess.downStreamMessage("ACQUISITION_MODE:OPEN"));
    }

    @Override
    public Observable<DeviceCandidate> newDevices() {
        return candidateSubject.asObservable();
    }

    @Override
    public void stopDiscovering() {
        exampleHardwareAccess.downStreamMessage("ACQUISITION_MODE:CLOSE");
    }

    @Override
    public void removeDevice(final String deviceId) {
        exampleHardwareAccess.downStreamMessage(String.format("REMOVE_DEVICE:%s", deviceId));
    }

    @Override
    public void start(final NetworkContext networkContext) {
        // Called by the SDK in order to start the NetworkLayer. From here, a real
        // network layer might connect to a serial port or construct any other
        // objects for the network layer to run.
        exampleHardwareAccess.connect();
        exampleHardwareAccess.upStreamMessages().subscribe(msg -> {
            String prefix = msg.split(":")[0];
            String[] values = msg.split(":")[1].split(",");
            String deviceId = values[0];

            switch (prefix) {
                case "NEW_DEVICE":
                    String manufacturer = values[1];
                    String model = values[2];
                    String version = values[3];
                    DeviceCandidate dc = new DeviceCandidate.Builder(NETWORK_IDENTIFIER, deviceId)
                            .autoAcquired(true).hardwareAddress(deviceId).driverMetadata(
                                    new DriverMetadata(NETWORK_IDENTIFIER, manufacturer, model, version)).build();
                    candidateSubject.onNext(dc);
                    break;
                case "REPORT_ATTRIBUTE":
                    String attributeId = values[1];
                    String value = values[2];
                    // Note, the type field here much be matched with an "onXXX" function in the driver.  In this case, onReportAttribute().
                    NetworkEvent evt = new NetworkEvent(deviceId, "ReportAttribute", String.format("%s=%s", attributeId, value), null);
                    eventSubject.onNext(evt);
                    break;
                default:
                    log.warn("Unrecognised message received from network");
            }
        });

    }

    @Override
    public void recoverDevice(final String s) {
        // In a real world network layer, this could be used for loading deviceId/nodeId mappings or establishing a
        // connection to the individual device. However, for our example network, nothing is required here.
        log.info("Recovering device {}", s);
    }

    @Override
    public Single<DeviceCandidate> interrogate(final DeviceCandidate deviceCandidate) {
        // Nothing further for us to do here so just return the DeviceCandidate straight back.
        return Single.just(deviceCandidate);
    }

    @Override
    public void close() {
        exampleHardwareAccess.disconnect();
    }
}
